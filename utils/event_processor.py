# d:\repoShaggy\EmotiView\EV_pipelines\EV_dataProcessor\utils\event_processor.py
import pandas as pd
import re
# This import will be removed. Configuration should be passed during instantiation.

class EventProcessor:
    def __init__(self, logger,
                 baseline_marker_start_eprime,
                 baseline_marker_end_eprime,
                 event_duration_default,
                 default_sfreq=None):
        self.logger = logger
        self.default_sfreq = default_sfreq # Reference sfreq if converting times to samples
        self.baseline_marker_start_eprime = baseline_marker_start_eprime
        self.baseline_marker_end_eprime = baseline_marker_end_eprime
        self.event_duration_default = event_duration_default
        self.logger.info("EventProcessor initialized.")

    def _derive_condition_from_filename(self, movie_filename):
        """
        Derives condition (e.g., Positive, Negative, Neutral) from movie filename.
        This should be consistent with QuestionnaireParser._derive_condition.
        """
        if not movie_filename:
            return "Unknown"
        name_upper = movie_filename.upper()
        if "NEG" in name_upper:
            return "Negative"
        elif "NEU" in name_upper:
            return "Neutral"
        elif "POS" in name_upper:
            return "Positive"
        elif "TRAI" in name_upper: # Training
            return "Training"
        # Add baseline markers if they are also identified via movieFilename logic (unlikely but possible)
        elif self.baseline_marker_start_eprime.upper() in name_upper:
             return self.baseline_marker_start_eprime
        elif self.baseline_marker_end_eprime.upper() in name_upper:
             return self.baseline_marker_end_eprime
        return "Other"

    def _extract_trial_identifier_eprime(self, frame_data):
        """
        Extracts the unique trial identifier (e.g., C{Cycle}_S{Sample}) from frame data.
        This must match the identifier generated by QuestionnaireParser.
        """
        movie_cycle = frame_data.get("movieList.Cycle", frame_data.get("movieTraining.Cycle", "N/A"))
        movie_sample = frame_data.get("movieList.Sample", frame_data.get("movieTraining.Sample", "N/A"))
        return f"C{movie_cycle}_S{movie_sample}"

    def process_event_log(self, eprime_txt_filepath):
        """
        Parses an E-Prime .txt log file to extract event information.

        Args:
            eprime_txt_filepath (str): Path to the E-Prime .txt file.

        Returns:
            pd.DataFrame: DataFrame with columns:
                          'onset_time_sec' (float): Onset time of the event in seconds
                                                    relative to the start of the E-Prime experiment log.
                                                    This will need to be synchronized with physiological data.
                          'duration_sec' (float): Duration of the event in seconds.
                          'condition' (str): Name of the condition (e.g., "Positive", "Negative", "Baseline_Start").
                          'trial_identifier_eprime' (str): Unique trial identifier (e.g., "C1_S1"),
                                                           especially for movie trials. NaN for non-trial events.
                          'movie_filename' (str, optional): Filename of the movie for movie trials.
        """
        self.logger.info(f"EventProcessor: Processing E-Prime log: {eprime_txt_filepath}")
        events_list = []

        try:
            # Attempt common E-Prime encodings
            try:
                with open(eprime_txt_filepath, 'r', encoding='utf-16-le', errors='ignore') as f:
                    content = f.read()
            except UnicodeDecodeError:
                with open(eprime_txt_filepath, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
        except Exception as e_read:
            self.logger.error(f"EventProcessor: Could not read file {eprime_txt_filepath}: {e_read}")
            return pd.DataFrame()

        # --- E-Prime Log Parsing Logic ---
        # This is highly dependent on your E-Prime file structure.
        # You need to identify LogFrames that correspond to the start of your trials
        # (e.g., movie presentations, baseline start/end).
        #
        # Key information to extract from relevant LogFrames:
        # 1. Event Onset Time:
        #    - E-Prime logs typically have timestamps like `Procedure.OnsetTime`, `Movie.OnsetTime`, etc.
        #    - These are usually relative to the start of the E-Prime session.
        #    - You'll need a strategy to synchronize these E-Prime times with your
        #      physiological data's timeline (e.g., using a common start marker sent from
        #      E-Prime to LSL, or aligning the first E-Prime event with the first XDF marker).
        #      For now, we'll assume these are E-Prime relative times.
        # 2. Event Duration:
        #    - For movies, this might be fixed or logged (e.g., `Movie.Duration`).
        #    - For baselines, it's the time between start and end markers.
        # 3. Condition Name:
        #    - Derived from `movieFilename` for movie trials.
        #    - Specific marker names for baseline (e.g., "Baseline_Start", "Baseline_End").
        # 4. Trial Identifier (for movies):
        #    - `C{Cycle}_S{Sample}` as used in QuestionnaireParser.

        log_frames = re.findall(r"\*\*\* LogFrame Start \*\*\*(.*?)\*\*\* LogFrame End \*\*\*", content, re.DOTALL)
        
        # Get experiment start time (first LogFrame's "Time" or a specific header field)
        # This is a placeholder; you might need a more robust way to get session start.
        experiment_start_time_eprime_ms = 0
        first_frame_match = re.search(r"Time:\s*(\d+)", log_frames[0] if log_frames else "", re.IGNORECASE)
        if first_frame_match:
            try:
                experiment_start_time_eprime_ms = int(first_frame_match.group(1))
                self.logger.info(f"EventProcessor: Estimated E-Prime experiment start time (ms): {experiment_start_time_eprime_ms}")
            except ValueError:
                 self.logger.warning("EventProcessor: Could not parse E-Prime experiment start time from first LogFrame. Assuming 0.")
        else:
            self.logger.warning("EventProcessor: Could not find E-Prime experiment start time from first LogFrame. Assuming 0.")


        for frame_str in log_frames:
            frame_data = {}
            for line in frame_str.strip().split('\n'):
                parts = line.split(":", 1)
                if len(parts) == 2:
                    frame_data[parts[0].strip()] = parts[1].strip()

            procedure = frame_data.get("Procedure")

            onset_time_ms_eprime_relative = None
            duration_sec = self.event_duration_default # Default duration
            condition_name = None
            trial_identifier = pd.NA
            movie_filename_val = None

            # --- TODO: Implement your E-Prime LogFrame parsing logic here ---
            # Identify relevant procedures and extract data
            
            # Example: Identifying a movie trial start
            if procedure in ["movieTrialProc", "movieTrainingProc"]:
                movie_filename_val = frame_data.get("movieFilename")
                condition_name = self._derive_condition_from_filename(movie_filename_val)
                trial_identifier = self._extract_trial_identifier_eprime(frame_data)
                
                # Get onset time for the movie presentation
                # Look for fields like 'Movie.OnsetTime', 'Stimulus.OnsetTime', or 'Procedure.OnsetTime'
                # The exact field name depends on your E-Prime script.
                # This example assumes 'movieStim.OnsetTime' exists and is the relevant one.
                onset_key_options = ["movieStim.OnsetTime", "Movie.OnsetTime", "Stimulus.OnsetTime", f"{procedure}.OnsetTime"]
                for key in onset_key_options:
                    if key in frame_data:
                        try:
                            onset_time_ms_eprime_absolute = int(frame_data[key])
                            onset_time_ms_eprime_relative = onset_time_ms_eprime_absolute - experiment_start_time_eprime_ms
                            break
                        except ValueError:
                            self.logger.warning(f"EventProcessor: Could not parse onset time for key '{key}' in {procedure}")
                
                if onset_time_ms_eprime_relative is None:
                    self.logger.warning(f"EventProcessor: Could not find onset time for {procedure} with movie {movie_filename_val}. Skipping this event.")
                    continue

                # Get duration (example, might be fixed or logged differently)
                # duration_sec = float(frame_data.get("Movie.Duration", self.event_duration_default * 1000)) / 1000.0
                # For now, using default. If movies have variable logged durations, extract that.
                # Example: if movie duration is logged in 'movieStim.Duration' in ms
                if "movieStim.Duration" in frame_data:
                    try:
                        duration_sec = int(frame_data["movieStim.Duration"]) / 1000.0
                    except ValueError:
                        self.logger.warning(f"EventProcessor: Could not parse duration for {movie_filename_val}. Using default.")


            # Example: Identifying baseline start/end markers
            # This is highly dependent on how you trigger/log baseline in E-Prime
            # Option 1: Specific text display marks start/end
            elif procedure == "baselineProc": # Assuming a procedure for baseline
                text_displayed = frame_data.get("TextDisplayed", frame_data.get("Instructions.Text")) # Or similar
                if text_displayed:
                    if self.baseline_marker_start_eprime.lower() in text_displayed.lower():
                        condition_name = self.baseline_marker_start_eprime
                        # Get onset of this text display or procedure
                        onset_key_options = [f"{procedure}.OnsetTime", "TextDisplay.OnsetTime"]
                        for key in onset_key_options:
                             if key in frame_data:
                                try:
                                    onset_time_ms_eprime_absolute = int(frame_data[key])
                                    onset_time_ms_eprime_relative = onset_time_ms_eprime_absolute - experiment_start_time_eprime_ms
                                    duration_sec = 0.1 # Baseline markers are point events
                                    break
                                except ValueError:
                                    self.logger.warning(f"EventProcessor: Could not parse onset time for baseline key '{key}'")
                        if onset_time_ms_eprime_relative is None: continue

                    elif self.baseline_marker_end_eprime.lower() in text_displayed.lower():
                        condition_name = self.baseline_marker_end_eprime
                        onset_key_options = [f"{procedure}.OnsetTime", "TextDisplay.OnsetTime"]
                        for key in onset_key_options:
                             if key in frame_data:
                                try:
                                    onset_time_ms_eprime_absolute = int(frame_data[key])
                                    onset_time_ms_eprime_relative = onset_time_ms_eprime_absolute - experiment_start_time_eprime_ms
                                    duration_sec = 0.1 # Baseline markers are point events
                                    break
                                except ValueError:
                                    self.logger.warning(f"EventProcessor: Could not parse onset time for baseline key '{key}'")
                        if onset_time_ms_eprime_relative is None: continue
            
            # Add other event types if necessary (e.g., button presses)

            if condition_name and onset_time_ms_eprime_relative is not None:
                onset_time_sec_eprime_relative = onset_time_ms_eprime_relative / 1000.0
                events_list.append({
                    'onset_time_sec': onset_time_sec_eprime_relative,
                    'duration_sec': duration_sec,
                    'condition': condition_name,
                    'trial_identifier_eprime': trial_identifier,
                    'movie_filename': movie_filename_val
                })
                self.logger.debug(f"EventProcessor: Added event - Cond: {condition_name}, Onset(s): {onset_time_sec_eprime_relative:.3f}, Dur(s): {duration_sec:.1f}, TrialID: {trial_identifier}")

        if not events_list:
            self.logger.warning(f"EventProcessor: No events extracted from {eprime_txt_filepath}.")
            return pd.DataFrame()

        events_df = pd.DataFrame(events_list)
        
        # --- Synchronization Step (Crucial) ---
        # The 'onset_time_sec' is currently relative to E-Prime's start.
        # This needs to be synchronized with the physiological data's timeline.
        #
        # Common strategies:
        # 1. Common Start Trigger: If E-Prime sends a unique marker (e.g., "ExperimentStart")
        #    to the LSL stream at the very beginning, and this marker is also logged by E-Prime
        #    with its E-Prime timestamp.
        #    - Find this marker's E-Prime time (`eprime_sync_marker_time_sec`).
        #    - Find this marker's XDF time (`xdf_sync_marker_time_sec`) from `DataLoader` (e.g., from `loaded_physiological_data['marker_times']`).
        #    - Calculate offset: `time_offset = xdf_sync_marker_time_sec - eprime_sync_marker_time_sec`.
        #    - Adjust all `events_df['onset_time_sec'] += time_offset`.
        #
        # 2. Align First Events: If the first E-Prime logged event (e.g., first movie)
        #    corresponds to the first XDF marker for that event type.
        #    - This is less robust if there are leading events or markers.
        #
        # This synchronization logic might need access to XDF marker times,
        # so `process_event_log` might need `loaded_physiological_data` as an argument,
        # or synchronization could happen in the orchestrator after both are loaded.
        # For now, this skeleton returns E-Prime relative times. The orchestrator
        # will need to handle the synchronization.
        
        self.logger.info(f"EventProcessor: Extracted {len(events_df)} events (times relative to E-Prime log start).")
        return events_df.sort_values(by='onset_time_sec').reset_index(drop=True)